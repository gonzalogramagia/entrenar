# Actualizaciones de Base de Datos - Entrenar App

## Cambios Recientes (2024)

### Nueva Tabla `workout_sessions`

#### Creación de la Tabla
```sql
CREATE TABLE public.workout_sessions (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    session_date DATE NOT NULL,
    session_name TEXT DEFAULT 'Rutina de Fullbody',
    total_exercises INTEGER DEFAULT 0,
    effort INTEGER DEFAULT 0 CHECK (effort >= 0 AND effort <= 3),
    mood INTEGER DEFAULT 0 CHECK (mood >= 0 AND mood <= 3),
    notes TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    CONSTRAINT workout_sessions_pkey PRIMARY KEY (id)
);
```

#### Índices para Optimización
```sql
CREATE INDEX idx_workout_sessions_user_id ON public.workout_sessions(user_id);
CREATE INDEX idx_workout_sessions_date ON public.workout_sessions(session_date);
CREATE INDEX idx_workout_sessions_user_date ON public.workout_sessions(user_id, session_date);
```

### Migración de Campos de Bienestar

#### Cambios en Tabla `workouts`
```sql
ALTER TABLE public.workouts ADD COLUMN exercise_session_id UUID DEFAULT gen_random_uuid();
ALTER TABLE public.workouts ALTER COLUMN serie TYPE INTEGER;
ALTER TABLE public.workouts ADD CONSTRAINT serie_positive CHECK (serie > 0);
```

#### Índices para `workouts`
```sql
CREATE INDEX idx_workouts_created_at ON public.workouts(created_at);
CREATE INDEX idx_workouts_exercise_session_id ON public.workouts(exercise_session_id);
CREATE INDEX idx_workouts_user_id_created_at ON public.workouts(user_id, created_at);
```

### Descripción de la Nueva Estructura

#### Tabla `workout_sessions`
- **Propósito**: Almacenar sesiones de entrenamiento completas
- **Granularidad**: Una sesión por día de entrenamiento
- **Métricas de bienestar**: `effort` y `mood` por sesión (más lógico)
- **Relación**: Una sesión puede tener múltiples workouts

#### Tabla `workouts` (Actualizada)
- **Propósito**: Almacenar series individuales de ejercicios
- **Granularidad**: Serie por serie
- **Agrupamiento**: `exercise_session_id` para agrupar series del mismo ejercicio
- **Relación**: Múltiples workouts pertenecen a una sesión

### Beneficios de la Nueva Estructura

#### 1. Mejor Normalización
- **Evita duplicación**: Un rating por sesión en lugar de por serie
- **Consistencia**: Los ratings de bienestar son por sesión, no por serie individual
- **Análisis**: Más fácil hacer análisis de tendencias por día

#### 2. Lógica de Negocio Mejorada
- **Sesión vs Serie**: El esfuerzo y ánimo son conceptos de sesión completa
- **UX**: Más intuitivo para el usuario (rating por día de entrenamiento)
- **Flexibilidad**: Permite agregar notas por sesión

#### 3. Rendimiento Optimizado
- **Consultas eficientes**: Índices específicos para fechas y usuarios
- **Agrupamiento rápido**: `exercise_session_id` para series relacionadas
- **Escalabilidad**: Estructura preparada para funcionalidades futuras

### Impacto en el Frontend

#### WorkoutHistory Component
- **Ratings por sesión**: Los campos `effort` y `mood` ahora están en `workout_sessions`
- **Agrupamiento mejorado**: `exercise_session_id` permite agrupar series por ejercicio
- **Modal detallado**: Muestra todas las series de un ejercicio específico
- **Filtro por fecha**: Optimizado con índices en `session_date`

#### Funcionalidades Actualizadas
1. **Ratings de bienestar**: Edición por sesión de entrenamiento
2. **Agrupamiento por ejercicio**: Cards individuales por ejercicio
3. **Modal de series**: Vista detallada con opción de borrado
4. **Filtro de calendario**: Solo muestra días con entrenamientos


### Próximas Mejoras Sugeridas

#### 1. Triggers para Actualización Automática
```sql
-- Trigger para actualizar total_exercises automáticamente
CREATE OR REPLACE FUNCTION update_session_exercise_count()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        UPDATE public.workout_sessions 
        SET total_exercises = total_exercises + 1
        WHERE session_date = DATE(NEW.created_at) AND user_id = NEW.user_id;
        RETURN NEW;
    ELSIF TG_OP = 'DELETE' THEN
        UPDATE public.workout_sessions 
        SET total_exercises = total_exercises - 1
        WHERE session_date = DATE(OLD.created_at) AND user_id = OLD.user_id;
        RETURN OLD;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;
```

#### 2. Vistas Optimizadas
```sql
-- Vista para días con entrenamientos
CREATE VIEW workout_days AS
SELECT 
    ws.session_date,
    ws.session_name,
    ws.total_exercises,
    ws.effort,
    ws.mood,
    ws.notes
FROM public.workout_sessions ws
WHERE ws.user_id = auth.uid()
ORDER BY ws.session_date DESC;
```

### Testing de los Cambios

#### Casos de Prueba
1. **Ratings por sesión**: Verificar que effort y mood se guarden en workout_sessions
2. **Agrupamiento**: Confirmar que exercise_session_id agrupe series correctamente
3. **Rendimiento**: Medir velocidad de consultas con nuevos índices
4. **Integridad**: Validar que constraints prevengan datos inválidos

#### Queries de Verificación
```sql
-- Verificar estructura de workout_sessions
SELECT column_name, data_type, is_nullable, column_default
FROM information_schema.columns
WHERE table_name = 'workout_sessions'
ORDER BY ordinal_position;

-- Verificar índices
SELECT indexname, indexdef
FROM pg_indexes
WHERE tablename IN ('workouts', 'workout_sessions');

-- Verificar constraints
SELECT conname, pg_get_constraintdef(oid)
FROM pg_constraint
WHERE conrelid IN ('public.workouts'::regclass, 'public.workout_sessions'::regclass);
```

